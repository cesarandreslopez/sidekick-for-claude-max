---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - sidekick-vscode/src/services/SecretsManager.ts
  - sidekick-vscode/src/services/ApiKeyClient.ts
  - sidekick-vscode/src/services/MaxSubscriptionClient.ts
  - sidekick-vscode/src/services/AuthService.ts
  - sidekick-vscode/src/types.ts
autonomous: true

must_haves:
  truths:
    - "AuthService can instantiate API key client when configured"
    - "AuthService can instantiate Max subscription client when configured"
    - "AuthService implements Disposable pattern"
    - "All async operations are non-blocking"
  artifacts:
    - path: "sidekick-vscode/src/services/AuthService.ts"
      provides: "Dual-auth abstraction layer"
      exports: ["AuthService"]
      min_lines: 50
    - path: "sidekick-vscode/src/services/ApiKeyClient.ts"
      provides: "Direct API key authentication"
      exports: ["ApiKeyClient"]
    - path: "sidekick-vscode/src/services/MaxSubscriptionClient.ts"
      provides: "Max subscription via claude-agent-sdk"
      exports: ["MaxSubscriptionClient"]
    - path: "sidekick-vscode/src/types.ts"
      provides: "Shared type definitions"
      exports: ["AuthMode", "ClaudeClient", "CompletionOptions"]
  key_links:
    - from: "AuthService"
      to: "ApiKeyClient"
      via: "conditional instantiation based on authMode"
      pattern: "new ApiKeyClient"
    - from: "AuthService"
      to: "MaxSubscriptionClient"
      via: "conditional instantiation based on authMode"
      pattern: "new MaxSubscriptionClient"
    - from: "AuthService"
      to: "SecretsManager"
      via: "dependency injection for API key retrieval"
      pattern: "secretsManager"
---

<objective>
Create the authentication service layer with dual-auth support.

Purpose: Build the core abstraction that allows switching between API key authentication (via @anthropic-ai/sdk) and Max subscription authentication (via @anthropic-ai/claude-agent-sdk). This is the foundation for all Claude API interactions.
Output: Four service files implementing the auth layer with proper TypeScript types and Disposable patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

@sidekick-vscode/src/extension.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared types and SecretsManager</name>
  <files>sidekick-vscode/src/types.ts, sidekick-vscode/src/services/SecretsManager.ts</files>
  <action>
Create src/types.ts with shared type definitions:

```typescript
export type AuthMode = 'api-key' | 'max-subscription';

export interface CompletionOptions {
  model?: string;
  maxTokens?: number;
  timeout?: number;
}

export interface ClaudeClient {
  complete(prompt: string, options?: CompletionOptions): Promise<string>;
  isAvailable(): Promise<boolean>;
  dispose(): void;
}
```

Create src/services/SecretsManager.ts for secure API key storage:

```typescript
import * as vscode from 'vscode';

export class SecretsManager {
  private static readonly API_KEY_KEY = 'sidekick.apiKey';

  constructor(private secrets: vscode.SecretStorage) {}

  async getApiKey(): Promise<string | undefined> {
    // Check environment variable first
    const envKey = process.env.ANTHROPIC_API_KEY;
    if (envKey) return envKey;

    // Then check secret storage
    return this.secrets.get(SecretsManager.API_KEY_KEY);
  }

  async setApiKey(key: string): Promise<void> {
    await this.secrets.store(SecretsManager.API_KEY_KEY, key);
  }

  async deleteApiKey(): Promise<void> {
    await this.secrets.delete(SecretsManager.API_KEY_KEY);
  }

  async hasApiKey(): Promise<boolean> {
    const key = await this.getApiKey();
    return !!key;
  }
}
```

Create the services directory if it doesn't exist: `mkdir -p sidekick-vscode/src/services`
  </action>
  <verify>
Files exist: `ls sidekick-vscode/src/types.ts sidekick-vscode/src/services/SecretsManager.ts`
TypeScript compiles: `cd sidekick-vscode && npx tsc --noEmit`
  </verify>
  <done>types.ts exports AuthMode, CompletionOptions, ClaudeClient. SecretsManager wraps VS Code SecretStorage.</done>
</task>

<task type="auto">
  <name>Task 2: Create ApiKeyClient and MaxSubscriptionClient</name>
  <files>sidekick-vscode/src/services/ApiKeyClient.ts, sidekick-vscode/src/services/MaxSubscriptionClient.ts</files>
  <action>
Create src/services/ApiKeyClient.ts implementing ClaudeClient using @anthropic-ai/sdk:

```typescript
import Anthropic from '@anthropic-ai/sdk';
import { ClaudeClient, CompletionOptions } from '../types';

export class ApiKeyClient implements ClaudeClient {
  private client: Anthropic;

  constructor(apiKey: string) {
    this.client = new Anthropic({ apiKey });
  }

  async complete(prompt: string, options?: CompletionOptions): Promise<string> {
    const message = await this.client.messages.create({
      model: this.mapModel(options?.model),
      max_tokens: options?.maxTokens ?? 1024,
      messages: [{ role: 'user', content: prompt }],
    });

    const textBlock = message.content.find(b => b.type === 'text');
    return textBlock?.text ?? '';
  }

  async isAvailable(): Promise<boolean> {
    try {
      // Simple test call with minimal tokens
      await this.client.messages.create({
        model: 'claude-3-5-haiku-20241022',
        max_tokens: 10,
        messages: [{ role: 'user', content: 'test' }],
      });
      return true;
    } catch {
      return false;
    }
  }

  private mapModel(model?: string): string {
    switch (model) {
      case 'haiku': return 'claude-3-5-haiku-20241022';
      case 'sonnet': return 'claude-sonnet-4-20250514';
      case 'opus': return 'claude-opus-4-20250514';
      default: return 'claude-3-5-haiku-20241022';
    }
  }

  dispose(): void {
    // No cleanup needed for API key client
  }
}
```

Create src/services/MaxSubscriptionClient.ts implementing ClaudeClient using @anthropic-ai/claude-agent-sdk:

```typescript
import { query } from '@anthropic-ai/claude-agent-sdk';
import { ClaudeClient, CompletionOptions } from '../types';

export class MaxSubscriptionClient implements ClaudeClient {
  async complete(prompt: string, options?: CompletionOptions): Promise<string> {
    const abortController = new AbortController();
    const timeoutMs = options?.timeout ?? 30000;
    const timeoutId = setTimeout(() => abortController.abort(), timeoutMs);

    try {
      for await (const message of query({
        prompt,
        options: {
          abortController,
          model: this.mapModel(options?.model),
          maxTurns: 1,
          allowedTools: [],
          permissionMode: 'bypassPermissions',
        }
      })) {
        if (message.type === 'result') {
          if (message.subtype === 'success') {
            return message.result;
          }
          throw new Error(message.errors?.join(', ') ?? 'Unknown error');
        }
      }
      throw new Error('No result received');
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error(`Request timed out after ${timeoutMs}ms`);
      }
      throw error;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  async isAvailable(): Promise<boolean> {
    try {
      // Check if Claude Code CLI is available
      const { execSync } = require('child_process');
      execSync('claude --version', { stdio: 'ignore' });
      return true;
    } catch {
      return false;
    }
  }

  private mapModel(model?: string): string {
    // Claude agent SDK uses simple names
    switch (model) {
      case 'haiku': return 'haiku';
      case 'sonnet': return 'sonnet';
      case 'opus': return 'opus';
      default: return 'haiku';
    }
  }

  dispose(): void {
    // No cleanup needed
  }
}
```

Note: The isAvailable() check in MaxSubscriptionClient uses execSync which is blocking. This is acceptable because:
1. It only runs once during connection test (not during completions)
2. The command is very fast (just --version check)
3. Alternative would require spawning async process for simple CLI existence check
  </action>
  <verify>
Files exist: `ls sidekick-vscode/src/services/ApiKeyClient.ts sidekick-vscode/src/services/MaxSubscriptionClient.ts`
TypeScript compiles: `cd sidekick-vscode && npx tsc --noEmit`
  </verify>
  <done>ApiKeyClient uses @anthropic-ai/sdk, MaxSubscriptionClient uses claude-agent-sdk query function.</done>
</task>

<task type="auto">
  <name>Task 3: Create AuthService orchestrator</name>
  <files>sidekick-vscode/src/services/AuthService.ts</files>
  <action>
Create src/services/AuthService.ts that manages the dual-auth abstraction:

```typescript
import * as vscode from 'vscode';
import { AuthMode, ClaudeClient, CompletionOptions } from '../types';
import { SecretsManager } from './SecretsManager';
import { ApiKeyClient } from './ApiKeyClient';
import { MaxSubscriptionClient } from './MaxSubscriptionClient';

export class AuthService implements vscode.Disposable {
  private client: ClaudeClient | undefined;
  private mode: AuthMode;
  private disposables: vscode.Disposable[] = [];
  private secretsManager: SecretsManager;

  constructor(context: vscode.ExtensionContext) {
    this.secretsManager = new SecretsManager(context.secrets);
    this.mode = this.getConfiguredMode();

    // Listen for configuration changes
    this.disposables.push(
      vscode.workspace.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration('sidekick.authMode')) {
          this.handleModeChange();
        }
      })
    );
  }

  private getConfiguredMode(): AuthMode {
    const config = vscode.workspace.getConfiguration('sidekick');
    return config.get<AuthMode>('authMode') ?? 'max-subscription';
  }

  private async handleModeChange(): Promise<void> {
    const newMode = this.getConfiguredMode();
    if (newMode !== this.mode) {
      this.mode = newMode;
      // Dispose old client
      this.client?.dispose();
      this.client = undefined;
    }
  }

  async getClient(): Promise<ClaudeClient> {
    if (this.client) {
      return this.client;
    }

    if (this.mode === 'api-key') {
      const apiKey = await this.secretsManager.getApiKey();
      if (!apiKey) {
        throw new Error('API key not configured. Run "Sidekick: Set API Key" command.');
      }
      this.client = new ApiKeyClient(apiKey);
    } else {
      this.client = new MaxSubscriptionClient();
    }

    return this.client;
  }

  async complete(prompt: string, options?: CompletionOptions): Promise<string> {
    const client = await this.getClient();
    return client.complete(prompt, options);
  }

  async testConnection(): Promise<{ success: boolean; message: string }> {
    try {
      const client = await this.getClient();
      const available = await client.isAvailable();

      if (available) {
        return {
          success: true,
          message: `Connected successfully using ${this.mode} authentication.`
        };
      } else {
        if (this.mode === 'max-subscription') {
          return {
            success: false,
            message: 'Claude Code CLI not found. Please install it: npm install -g @anthropic-ai/claude-code'
          };
        }
        return {
          success: false,
          message: 'API key authentication failed. Please check your API key.'
        };
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, message };
    }
  }

  getMode(): AuthMode {
    return this.mode;
  }

  getSecretsManager(): SecretsManager {
    return this.secretsManager;
  }

  dispose(): void {
    this.client?.dispose();
    this.disposables.forEach(d => d.dispose());
  }
}
```

Key design decisions:
1. Lazy client initialization (only create when first needed)
2. Config change listener to handle mode switching at runtime
3. Proper Disposable pattern for cleanup
4. SecretsManager injected via constructor for testability
5. testConnection() method for the Test Connection command
  </action>
  <verify>
File exists: `ls sidekick-vscode/src/services/AuthService.ts`
TypeScript compiles: `cd sidekick-vscode && npx tsc --noEmit`
All exports available: `grep -l "export class" sidekick-vscode/src/services/*.ts`
  </verify>
  <done>AuthService orchestrates both auth modes, implements Disposable, listens for config changes.</done>
</task>

</tasks>

<verification>
After all tasks:
1. All service files exist in sidekick-vscode/src/services/
2. types.ts exists with shared types
3. `npx tsc --noEmit` passes (no type errors)
4. `npm run compile` succeeds (esbuild bundles everything)
</verification>

<success_criteria>
- types.ts exports AuthMode, ClaudeClient, CompletionOptions
- SecretsManager wraps VS Code SecretStorage with async API
- ApiKeyClient implements ClaudeClient using @anthropic-ai/sdk
- MaxSubscriptionClient implements ClaudeClient using claude-agent-sdk
- AuthService manages mode switching and client lifecycle
- All classes use proper async patterns (no blocking)
- AuthService implements vscode.Disposable
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
