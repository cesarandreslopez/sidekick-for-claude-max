---
phase: 02-completions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sidekick-vscode/src/types.ts
  - sidekick-vscode/src/services/CompletionCache.ts
  - sidekick-vscode/src/services/CompletionService.ts
  - sidekick-vscode/src/utils/prompts.ts
autonomous: true

must_haves:
  truths:
    - "CompletionService can return cached completions for repeated identical contexts"
    - "CompletionService debounces rapid requests (only one API call per typing pause)"
    - "CompletionService cancels in-flight requests when new request arrives"
    - "Prompt templates produce code-only output from Claude (no conversational text)"
  artifacts:
    - path: "sidekick-vscode/src/services/CompletionCache.ts"
      provides: "LRU cache with TTL for completion results"
      exports: ["CompletionCache"]
    - path: "sidekick-vscode/src/services/CompletionService.ts"
      provides: "Orchestrates caching, debouncing, cancellation, API calls"
      exports: ["CompletionService"]
    - path: "sidekick-vscode/src/utils/prompts.ts"
      provides: "System and user prompt templates for completions"
      exports: ["getSystemPrompt", "getUserPrompt", "cleanCompletion"]
    - path: "sidekick-vscode/src/types.ts"
      provides: "Extended with CompletionContext interface"
      contains: "CompletionContext"
  key_links:
    - from: "CompletionService"
      to: "AuthService.complete()"
      via: "constructor injection"
      pattern: "authService\\.complete"
    - from: "CompletionService"
      to: "CompletionCache"
      via: "composition"
      pattern: "this\\.cache\\.(get|set)"
---

<objective>
Create CompletionService with caching, debouncing, cancellation, and prompt templates.

Purpose: CompletionService wraps AuthService with completion-specific logic (caching, debouncing, prompts) so the InlineCompletionProvider can remain simple.

Output: CompletionCache.ts, CompletionService.ts, prompts.ts, extended types.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-completions/02-RESEARCH.md

@sidekick-vscode/src/types.ts
@sidekick-vscode/src/services/AuthService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CompletionCache and extend types</name>
  <files>
    sidekick-vscode/src/types.ts
    sidekick-vscode/src/services/CompletionCache.ts
  </files>
  <action>
    1. Extend `sidekick-vscode/src/types.ts` with:
       ```typescript
       /**
        * Context for a completion request (used for caching).
        */
       export interface CompletionContext {
         /** Programming language identifier */
         language: string;
         /** Model shorthand (haiku, sonnet, opus) */
         model: string;
         /** Code before cursor (last ~500 chars used for cache key) */
         prefix: string;
         /** Code after cursor (first ~200 chars used for cache key) */
         suffix: string;
         /** Whether this is a multi-line completion request */
         multiline: boolean;
         /** Filename for context */
         filename: string;
       }
       ```

    2. Create `sidekick-vscode/src/services/CompletionCache.ts`:
       - LRU cache using native Map (preserves insertion order)
       - Constructor accepts maxSize (default 100) and ttlMs (default 30000)
       - hashKey(context: CompletionContext): string - creates cache key from language, model, last 500 chars of prefix, first 200 chars of suffix
       - get(context): string | undefined - returns cached completion if exists and not expired, moves to end for LRU
       - set(context, completion): void - stores completion, evicts oldest if at capacity
       - clear(): void - clears all entries
       - Private interface CacheEntry { completion: string; timestamp: number; }
  </action>
  <verify>
    `cd sidekick-vscode && npx tsc --noEmit` passes with no errors
  </verify>
  <done>
    CompletionCache class exists with get/set/clear methods, CompletionContext type exported from types.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create prompt templates and response cleaning</name>
  <files>
    sidekick-vscode/src/utils/prompts.ts
  </files>
  <action>
    Create `sidekick-vscode/src/utils/prompts.ts` with:

    1. `getSystemPrompt(multiline: boolean): string`
       - For multiline: "block/function" completions, "up to 10 lines"
       - For single-line: "line/statement" completions, "1-3 lines"
       - Rules in prompt:
         - Output ONLY code that completes the block/line
         - If unsure, output reasonable default (None, 0, "", [], {})
         - NEVER ask questions or explain
         - NEVER say you need more context
         - NO markdown, NO backticks
         - Maximum N lines

    2. `getUserPrompt(language: string, filename: string, prefix: string, suffix: string): string`
       - Format: `{language} | {filename}\n\n{prefix}<CURSOR>{suffix}\n\nCompletion:`
       - The <CURSOR> marker indicates where completion should be inserted

    3. `cleanCompletion(text: string, multiline: boolean): string | undefined`
       - Remove markdown code block markers (```language\n and \n```)
       - Trim whitespace
       - Filter conversational responses using patterns:
         - /^I (need|cannot|can't|don't|would|could)/i
         - /^(Could|Would|Can) you/i
         - /more context/i
         - /cannot provide/i
         - /please provide/i
         - /let me/i
         - /however/i
         - /without (additional|more)/i
       - If any pattern matches, return undefined
       - Check length: maxLength = multiline ? 1000 : 200
       - If too long, return undefined
       - Return cleaned string or undefined if empty
  </action>
  <verify>
    `cd sidekick-vscode && npx tsc --noEmit` passes with no errors
  </verify>
  <done>
    prompts.ts exports getSystemPrompt, getUserPrompt, cleanCompletion functions
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CompletionService orchestrating cache, debounce, cancellation</name>
  <files>
    sidekick-vscode/src/services/CompletionService.ts
  </files>
  <action>
    Create `sidekick-vscode/src/services/CompletionService.ts`:

    1. Import dependencies:
       - vscode (for CancellationToken, workspace config, TextDocument, Position)
       - AuthService from ./AuthService
       - CompletionCache from ./CompletionCache
       - CompletionContext from ../types
       - getSystemPrompt, getUserPrompt, cleanCompletion from ../utils/prompts

    2. Class CompletionService implements vscode.Disposable:
       - Private fields:
         - cache: CompletionCache
         - authService: AuthService
         - pendingController: AbortController | undefined
         - debounceTimer: NodeJS.Timeout | undefined
         - lastRequestId: number = 0

       - Constructor(authService: AuthService):
         - Store authService reference
         - Create new CompletionCache()

       - async getCompletion(document: TextDocument, position: Position, token: CancellationToken): Promise<string | undefined>:
         1. Read config: debounceMs, inlineContextLines, multiline, inlineModel
         2. Increment requestId for tracking
         3. Cancel any pending request: this.pendingController?.abort()
         4. Clear debounce timer if exists, create new timer
         5. await debounce delay
         6. Check if requestId still current and token not cancelled, return undefined if stale
         7. Build CompletionContext from document/position (extract prefix/suffix with contextLines limit)
         8. Check cache: if hit, return cached completion
         9. Create new AbortController, link token.onCancellationRequested to abort
         10. Build prompt using getSystemPrompt + getUserPrompt
         11. Call authService.complete(prompt, { model, maxTokens: 200, timeout: 10000 })
         12. Check requestId and token again after await
         13. Clean completion with cleanCompletion()
         14. If valid, cache it and return
         15. Catch AbortError and return undefined (not an error)

       - private buildContext(document, position, config): CompletionContext
         - Get language, filename from document
         - Calculate prefix (lines before cursor up to contextLines)
         - Calculate suffix (lines after cursor up to contextLines)
         - Return { language, model, prefix, suffix, multiline, filename }

       - private buildPrompt(context: CompletionContext): string
         - Return system prompt + "\n\n" + user prompt

       - dispose(): void
         - Abort pending controller
         - Clear debounce timer
         - Clear cache
  </action>
  <verify>
    `cd sidekick-vscode && npx tsc --noEmit` passes with no errors
  </verify>
  <done>
    CompletionService exists with getCompletion() method that handles debouncing, caching, cancellation, and calls AuthService
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd sidekick-vscode && npx tsc --noEmit` - Type checking passes
2. `cd sidekick-vscode && npm run compile` - Build succeeds
3. Verify exports: CompletionCache, CompletionService, CompletionContext, prompt functions all accessible
</verification>

<success_criteria>
- CompletionCache provides LRU caching with TTL expiration
- CompletionService orchestrates: debounce -> cache check -> API call -> cache store
- Prompt templates produce code-only completions (system prompt instructs no explanations)
- Response cleaning filters conversational/markdown responses
- All code type-checks and builds
</success_criteria>

<output>
After completion, create `.planning/phases/02-completions/02-01-SUMMARY.md`
</output>
