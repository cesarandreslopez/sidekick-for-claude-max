---
phase: 02-completions
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - sidekick-vscode/src/providers/InlineCompletionProvider.ts
  - sidekick-vscode/src/extension.ts
autonomous: true

must_haves:
  truths:
    - "User sees ghost text completions appear after typing pauses"
    - "User can accept full completion with Tab key"
    - "User can accept word-by-word with Ctrl+Right"
    - "Completions are cached (same context returns instant result)"
    - "User can configure which model is used for completions"
    - "Multi-line completions display correctly"
  artifacts:
    - path: "sidekick-vscode/src/providers/InlineCompletionProvider.ts"
      provides: "VS Code InlineCompletionItemProvider implementation"
      exports: ["InlineCompletionProvider"]
    - path: "sidekick-vscode/src/extension.ts"
      provides: "Extension wiring CompletionService and InlineCompletionProvider"
      contains: "CompletionService"
  key_links:
    - from: "InlineCompletionProvider"
      to: "CompletionService.getCompletion()"
      via: "constructor injection"
      pattern: "completionService\\.getCompletion"
    - from: "extension.ts"
      to: "InlineCompletionProvider"
      via: "registerInlineCompletionItemProvider"
      pattern: "registerInlineCompletionItemProvider"
    - from: "extension.ts"
      to: "CompletionService"
      via: "instantiation with AuthService"
      pattern: "new CompletionService"
---

<objective>
Extract InlineCompletionProvider to dedicated file and wire it to use CompletionService instead of HTTP server.

Purpose: Complete the migration from HTTP server to direct SDK calls for inline completions. The provider becomes a thin layer that delegates to CompletionService.

Output: InlineCompletionProvider.ts extracted, extension.ts simplified, HTTP fetch code removed
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-completions/02-RESEARCH.md
@.planning/phases/02-completions/02-01-SUMMARY.md

@sidekick-vscode/src/extension.ts
@sidekick-vscode/src/services/AuthService.ts
@sidekick-vscode/src/services/CompletionService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract InlineCompletionProvider to dedicated file</name>
  <files>
    sidekick-vscode/src/providers/InlineCompletionProvider.ts
  </files>
  <action>
    Create `sidekick-vscode/src/providers/InlineCompletionProvider.ts`:

    1. Import dependencies:
       - vscode (InlineCompletionItemProvider, InlineCompletionItem, InlineCompletionContext, TextDocument, Position, Range, CancellationToken, workspace)
       - CompletionService from ../services/CompletionService

    2. Export class InlineCompletionProvider implements vscode.InlineCompletionItemProvider:

       - Constructor(private completionService: CompletionService)
         - Store reference to completionService

       - async provideInlineCompletionItems(
           document: TextDocument,
           position: Position,
           context: InlineCompletionContext,
           token: CancellationToken
         ): Promise<InlineCompletionItem[] | undefined>

         Implementation:
         1. Check config: if not enabled, return undefined
            ```typescript
            const config = vscode.workspace.getConfiguration('sidekick');
            if (!config.get('enabled')) {
              return undefined;
            }
            ```
         2. Check if token already cancelled, return undefined
         3. try/catch block:
            - Call completionService.getCompletion(document, position, token)
            - If no completion or token cancelled, return undefined
            - Return array with single InlineCompletionItem:
              ```typescript
              return [
                new vscode.InlineCompletionItem(
                  completion,
                  new vscode.Range(position, position)
                ),
              ];
              ```
         4. catch: log error to console.error, return undefined

    Note: Tab acceptance and Ctrl+Right partial accept are handled automatically by VS Code - no extension code needed. The InlineCompletionItem handles this.
  </action>
  <verify>
    `cd sidekick-vscode && npx tsc --noEmit` passes with no errors
  </verify>
  <done>
    InlineCompletionProvider.ts exists in providers/ directory and type-checks correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CompletionService and InlineCompletionProvider in extension.ts</name>
  <files>
    sidekick-vscode/src/extension.ts
  </files>
  <action>
    Update `sidekick-vscode/src/extension.ts`:

    1. Add imports at top:
       ```typescript
       import { CompletionService } from './services/CompletionService';
       import { InlineCompletionProvider } from './providers/InlineCompletionProvider';
       ```

    2. Add module-level variable:
       ```typescript
       let completionService: CompletionService | undefined;
       ```

    3. In activate() function, AFTER authService initialization:
       ```typescript
       // Initialize completion service (depends on authService)
       completionService = new CompletionService(authService);
       context.subscriptions.push(completionService);

       // Register inline completion provider using CompletionService
       const inlineProvider = new InlineCompletionProvider(completionService);
       const inlineDisposable = vscode.languages.registerInlineCompletionItemProvider(
         { pattern: '**' }, // All files
         inlineProvider
       );
       context.subscriptions.push(inlineDisposable);
       ```

    4. REMOVE the old SidekickInlineCompletionProvider class entirely (lines ~279-480)
       - This includes the class definition
       - The fetchCompletion method
       - The getCompletion method that uses HTTP

    5. REMOVE unused imports:
       - Remove: `import * as https from 'https';`
       - Remove: `import * as http from 'http';`

    6. REMOVE old interfaces that are no longer needed:
       - Keep CompletionResponse (might be used by transform, check first)
       - Actually: Keep both interfaces, they're used by fetchTransform which stays until Phase 3

    7. REMOVE old module-level variables that are now handled by CompletionService:
       - Remove: `let debounceTimer: NodeJS.Timeout | undefined;`
       - Remove: `let lastRequestId = 0;`

    8. REMOVE old provider registration (the "const provider = new SidekickInlineCompletionProvider();" and related lines)

    9. In deactivate() function:
       - Remove the debounceTimer cleanup (now handled by CompletionService.dispose())
       - The function can be empty or just have a comment
       ```typescript
       export function deactivate(): void {
         // Cleanup handled via context.subscriptions (AuthService, CompletionService)
       }
       ```

    Keep everything else:
    - Status bar item
    - Toggle command
    - TriggerCompletion command
    - SetApiKey command
    - TestConnection command
    - Transform command (still uses HTTP until Phase 3)
    - fetchTransform function (needed until Phase 3)
  </action>
  <verify>
    `cd sidekick-vscode && npm run compile` - Build succeeds without errors
  </verify>
  <done>
    extension.ts creates CompletionService, registers InlineCompletionProvider, old HTTP-based code removed
  </done>
</task>

<task type="auto">
  <name>Task 3: Update inlineModel setting to include opus option</name>
  <files>
    sidekick-vscode/package.json
  </files>
  <action>
    Update `sidekick-vscode/package.json` to add opus to inlineModel options:

    Find the sidekick.inlineModel configuration and update:
    ```json
    "sidekick.inlineModel": {
      "type": "string",
      "enum": [
        "haiku",
        "sonnet",
        "opus"
      ],
      "default": "haiku",
      "description": "Model for inline completions (haiku=fast, sonnet=balanced, opus=quality)",
      "enumDescriptions": [
        "Claude Haiku - Fastest completions (recommended for inline)",
        "Claude Sonnet - Balanced speed and quality",
        "Claude Opus - Highest quality, slower"
      ]
    }
    ```

    This satisfies COMP-08: User can configure model for completions (Haiku/Sonnet/Opus)
  </action>
  <verify>
    JSON is valid: `cd sidekick-vscode && node -e "require('./package.json')"`
  </verify>
  <done>
    inlineModel setting includes haiku, sonnet, and opus options
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd sidekick-vscode && npm run compile` - Build succeeds
2. `cd sidekick-vscode && npx tsc --noEmit` - Type checking passes
3. Verify in VS Code:
   - Open a file, type some code, pause - ghost text should appear
   - Press Tab - completion should be accepted
   - Press Ctrl+Right - should accept word by word
   - Change sidekick.inlineModel setting - should work with all three models
</verification>

<success_criteria>
- InlineCompletionProvider is a thin wrapper delegating to CompletionService
- extension.ts no longer has HTTP fetch code for completions (transform still uses HTTP until Phase 3)
- Completions work via SDK instead of server
- Tab and Ctrl+Right acceptance work (VS Code built-in)
- Model selection includes haiku, sonnet, and opus
- All COMP-* requirements satisfied:
  - COMP-01: Ghost text completions (InlineCompletionProvider returns items)
  - COMP-02: Tab acceptance (VS Code built-in)
  - COMP-03: Ctrl+Right partial accept (VS Code built-in)
  - COMP-04: Debouncing (CompletionService handles)
  - COMP-05: Cancellation (CompletionService handles via AbortController)
  - COMP-06: Multi-line (Just return multi-line string in InlineCompletionItem)
  - COMP-07: Caching (CompletionCache in CompletionService)
  - COMP-08: Model config (package.json enum includes all three)
</success_criteria>

<output>
After completion, create `.planning/phases/02-completions/02-02-SUMMARY.md`
</output>
